# AI駆動テスト開発ガイド (AI-TDD Development Guide)

## 概要

本ドキュメントは、AIを活用したテスト駆動開発（AI-TDD）の包括的なガイドです。
業務仕様を原本として管理し、それに基づいてテスト設計・機能実装を行う標準プロセスを定義します。

**最終更新**: 2026-01-02
**対象プロジェクト**: OshiCall

---

## 🎯 目的

- **AIの最大活用**: コーディング、テスト、ドキュメント作成をAIに任せる
- **安全性**: DB破壊や予期せぬバグを防ぐ
- **並行開発**: Git worktreeを使い、メイン環境を汚さずにAIにタスクを依頼する
- **品質保証**: テスト駆動開発により、業務仕様に基づいた実装を保証する

---

## 🛠️ ツールと役割

| ツール | 役割 | 使いどころ |
|--------|------|------------|
| **Cursor (Claude)** | **実行部隊 (Hands)** | コードの記述、コマンド実行、ブラウザ操作、テスト実行。Phase 0-2の実装を担当 |
| **Gemini 1.5 Pro** | **参謀 (Brain)** | 大規模なコンテキスト（全コード）を読み込んだ設計、リファクタリング提案、複雑なバグ調査 |
| **ChatGPT** | **専門家 (Advisor)** | セカンドオピニオン、特定のアルゴリズム生成、コードレビュー |
| **Git Worktree** | **作業場 (Workspace)** | AI用の隔離された作業ディレクトリ。メインブランチを切り替えずに並行作業が可能 |

---

## 📚 ドキュメント体系

### 階層構造

```
業務仕様（What）
    ↓ 導出
テスト仕様（検証基準）
    ↓ 導出
機能仕様（How）
    ↓ 実装
コード
```

### ディレクトリ構成

```
docs/
├── business/                    # 業務仕様（原本）
│   ├── README.md                # 業務仕様一覧・概要
│   ├── auction.md               # オークション業務
│   ├── video-call.md            # ビデオ通話業務
│   ├── payment.md               # 決済業務
│   └── user-management.md       # ユーザー管理業務
│
├── functional/                  # 機能仕様（実装方針）
│   ├── README.md                # 機能仕様一覧
│   └── [機能名].md
│
├── test/                        # テスト関連
│   ├── plans/                   # テスト計画書
│   │   └── [機能名]_TEST_PLAN.md
│   ├── E2E_TEST_GUIDE.md        # E2Eテストガイド
│   └── TEST_ACCOUNTS.md         # テストアカウント情報
│
└── ai_workflow/                 # AI開発プロセス
    ├── AI_TDD_DEVELOPMENT_GUIDE.md  # このドキュメント
    ├── CODE_CHANGE_WORKFLOW.md  # コード変更ワークフロー
    └── templates/               # プロンプトテンプレート
```

---

## 📋 仕様書の定義

### 業務仕様（Business Specification）

**目的**: ビジネス要件を定義する原本ドキュメント

**特徴**:
- 「何を実現したいか（What）」を記述
- 技術的な実装方法には言及しない
- ユーザーストーリー、ビジネスルール、制約を定義
- 変更頻度は低い（ビジネス要件の変更時のみ更新）
- **原本として厳格に管理**

**配置**: `/docs/business/[業務名].md`

**フォーマット**:
```markdown
# [業務名]

## 概要
[この業務の目的と背景]

## ユーザーストーリー
- As a [ユーザー種別], I want to [行動], so that [目的]

## ビジネスルール
### BR-001: [ルール名]
- [ルールの説明]
- 条件: [適用条件]
- 結果: [期待される結果]

## 業務フロー
[フロー図やシーケンス]

## 用語定義
| 用語 | 定義 |
|------|------|

## 制約事項
- [ビジネス上の制約]

## 変更履歴
| 日付 | 変更内容 | 理由 | 承認者 |
|------|----------|------|--------|
```

---

### 機能仕様（Functional Specification）

**目的**: 業務仕様を実現するための技術的な実装方針を定義

**特徴**:
- 「どう実現するか（How）」を記述
- 業務仕様から導出される
- 技術的な設計、API設計、データ構造を定義
- 実装・修正ごとに更新される

**配置**: `/docs/functional/[機能名].md`

**フォーマット**:
```markdown
# [機能名]

## 対応する業務仕様
- /docs/business/[業務名].md の BR-001, BR-002

## 機能要件
### FR-001: [要件名]
- 説明:
- トリガー:
- 処理内容:
- 出力:

## 技術設計
### データ構造
[テーブル、カラム、型]

### API設計
[エンドポイント、リクエスト、レスポンス]

### 状態遷移
[状態遷移図]

## 関連ファイル
- backend/src/...
- src/...

## 変更履歴
| 日付 | 変更内容 | 対応Issue |
|------|----------|-----------|
```

---

### テスト計画書（Test Plan）

**目的**: 業務仕様の検証基準を定義

**特徴**:
- 業務仕様のビジネスルール（BR-xxx）を検証するテストケース
- 機能仕様の機能要件（FR-xxx）を検証するテストケース
- テストは業務仕様から導出（機能仕様からではない）

**配置**: `/docs/test/plans/[機能名]_TEST_PLAN.md`

---

## 🔄 AI-TDD開発フロー

```
┌─────────────────────────────────────────────────────────────────┐
│ Phase 0: 業務仕様の確認・更新                                    │
│ ├── 既存の業務仕様を確認                                        │
│ ├── 新規/変更の場合は業務仕様を更新                             │
│ └── 業務仕様の承認                                              │
│ → 成果物: /docs/business/[業務名].md（更新）                    │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Phase 1: テスト設計                                              │
│ ├── 業務仕様のBR-xxxに対応するテストケース設計                  │
│ ├── テスト計画書作成                                            │
│ └── テストコード作成（この時点では失敗する）                    │
│ → 成果物: /docs/test/plans/[機能名]_TEST_PLAN.md               │
│ → 成果物: e2e/*.spec.ts, src/**/*.test.ts                       │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Phase 2: 機能設計・実装                                          │
│ ├── 作業環境の準備（Git Worktree）                              │
│ ├── 機能仕様の作成/更新                                         │
│ ├── テストが通るように実装                                      │
│ └── ローカルで npm run ci 確認                                  │
│ → 成果物: /docs/functional/[機能名].md                          │
│ → 成果物: 実装コード                                            │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Phase 3: レビューとマージ                                        │
│ ├── AIの作業が完了したら、メイン環境でDiffを確認                │
│ ├── 問題なければマージ                                         │
│ ├── Worktreeの削除                                             │
│ └── GitHubへのPush                                             │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Phase 4: Pull Request & CI                                       │
│ ├── feature ブランチ作成 & push                                 │
│ ├── GitHub Actions 自動実行                                     │
│ └── レビュー & マージ                                           │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Phase 5: デプロイ                                                │
│ ├── main マージ → Staging 自動デプロイ                          │
│ ├── Staging で動作確認                                          │
│ └── Production 手動デプロイ                                     │
└─────────────────────────────────────────────────────────────────┘
```

---

## Phase 0: 業務仕様の確認・更新

### 目的
開発する機能が、どの業務仕様に基づくかを明確にする。
業務仕様が存在しない/不足している場合は、先に業務仕様を整備する。

### プロセス

#### ケース A: 既存機能のバグ修正
1. 関連する業務仕様を確認（`/docs/business/`）
2. 業務仕様通りに動作していないことを確認
3. 業務仕様は変更せず、Phase 1 へ

#### ケース B: 既存機能の仕様変更
1. 関連する業務仕様を確認
2. **業務仕様の変更が必要な場合は、先に業務仕様を更新**
3. 変更履歴に記録、承認を得る
4. Phase 1 へ

#### ケース C: 新機能追加
1. 新しい業務仕様ドキュメントを作成
2. 承認を得る
3. Phase 1 へ

### Cursor へのプロンプト（業務仕様の確認）

```
# 業務仕様の確認

## 対応したい問題/機能
[問題や機能の説明]

## 依頼内容

### Step 1: 関連する業務仕様の調査

1. /docs/business/ 配下の既存ドキュメントを確認
2. この問題/機能に関連するビジネスルール（BR-xxx）を特定
3. 以下の形式で報告

【業務仕様確認レポート】

■ 関連する業務仕様:
  - /docs/business/[業務名].md
    - BR-001: [ルール名] - [関連度: 直接/間接]
    - BR-002: ...

■ 業務仕様の更新要否:
  - [ ] 更新不要（既存の業務仕様通りに動作すべき）
  - [ ] 更新必要（理由: ）

■ 対応方針:
  - バグ修正 / 仕様変更 / 新機能

### 重要
- コードは変更しない
- 業務仕様の変更が必要な場合は、先に業務仕様の更新案を提示
```

### Cursor へのプロンプト（業務仕様の新規作成/更新）

```
# 業務仕様の作成/更新

## 対象
[業務名]

## 依頼内容

/docs/business/[業務名].md を作成/更新してください。

### フォーマット

# [業務名]

## 概要
[この業務の目的と背景]

## ユーザーストーリー
- As a [ユーザー種別], I want to [行動], so that [目的]

## ビジネスルール

### BR-001: [ルール名]
- 説明: [ルールの説明]
- 条件: [適用条件]
- 結果: [期待される結果]

### BR-002: ...

## 業務フロー
[状態遷移やフロー図]

## 制約事項
- [ビジネス上の制約]

## 変更履歴
| 日付 | 変更内容 | 理由 | 承認者 |
|------|----------|------|--------|

### 重要
- 技術的な実装方法には言及しない
- ユーザー視点でのビジネスルールを記述
- 承認後に Phase 1 へ進む
```

---

## Phase 1: テスト設計

### 目的
業務仕様のビジネスルール（BR-xxx）を検証するテストを設計する。

### 重要な原則
- **テストは業務仕様から導出する**（機能仕様からではない）
- テストケースの ID は業務仕様の BR-xxx と対応させる
- この時点でテストコードは失敗する（実装がないため）

### Cursor へのプロンプト

```
# テスト設計

## 対象業務仕様
/docs/business/[業務名].md

## 対象ビジネスルール
- BR-001: [ルール名]
- BR-002: [ルール名]

## 依頼内容

### Step 1: テストケース設計（まず報告）

各ビジネスルールに対するテストケースを設計：

BR-001: [ルール名]
  ✓ 正常系: [ビジネスルールが正しく適用されるケース]
  ✓ 正常系: [別の正常ケース]
  ✗ 異常系: [ルール違反のケース]
  ⚠ エッジケース: [境界条件]

BR-002: ...

### Step 2: テスト計画書作成（承認後）

/docs/test/plans/[機能名]_TEST_PLAN.md を作成

### Step 3: テストコード作成（承認後）

// E2Eテスト (Playwright)
test.describe('[業務名]', () => {
  test.describe('BR-001: [ルール名]', () => {
    test('正常系: [期待動作]', async ({ page }) => {
      // テストコード
    });
  });
});

// ユニットテスト (Vitest)
describe('[機能名]', () => {
  describe('BR-001: [ルール名]', () => {
    it('正常系: [期待動作]', () => {
      // テストコード
    });
  });
});

### 重要
- テストケースは業務仕様の BR-xxx と対応させる
- 実装コードは書かない（テストのみ）
- テストは失敗する状態でOK
```

---

## Phase 2: 機能設計・実装

### 目的
テストが通るように機能を設計・実装する。

### プロセス

#### 2.1 作業環境の準備（Git Worktree）

メインの作業ディレクトリをクリーンに保つため、AI用の作業ディレクトリを作成します。

**推奨構成**:
プロジェクトルートの隣にWorktree用のディレクトリを作成し、それをエディタ（Cursor/VSCode）のワークスペースに追加します。

```bash
# 1. Worktreeの作成 (例: feat/new-function ブランチ)
git worktree add ../oshicall-feat-new-function -b feat/new-function

# 2. エディタでフォルダを追加
# VSCode/Cursor: "File" -> "Add Folder to Workspace..." で作成したディレクトリを選択
```

> **なぜWorktreeか？**
> ブランチ切り替え (`git checkout`) は、node_modulesの再インストールやビルドキャッシュの不整合を引き起こすことがあります。Worktreeなら完全に独立したディレクトリでAIに作業させ、自分はメイン環境でレビューや別作業ができます。

#### 2.2 機能仕様の作成

#### 2.3 実装

#### 2.4 テスト通過確認

### Cursor へのプロンプト（機能仕様の作成）

```
# 機能仕様の作成

## 対象業務仕様
/docs/business/[業務名].md の BR-001, BR-002

## 対象テスト
/docs/test/plans/[機能名]_TEST_PLAN.md

## 依頼内容

### Step 1: 現状調査（まず報告）

1. 関連するコードを調査
2. 現在の実装状況を確認
3. 以下の形式で報告

【現状調査レポート】

■ 関連ファイル:
  - backend/src/...
  - src/...

■ 現在の実装状況:
  - [どこまで実装されているか]

■ テストを通すために必要な変更:
  - [変更概要]

### Step 2: 機能仕様作成（承認後）

/docs/functional/[機能名].md を作成

### 重要
- 機能仕様は「業務仕様をどう実現するか」を記述
- 業務仕様の BR-xxx と機能仕様の FR-xxx を対応させる
```

### Cursor へのプロンプト（実装）

```
# 実装

## 対象
- 業務仕様: /docs/business/[業務名].md
- 機能仕様: /docs/functional/[機能名].md
- テスト: e2e/[機能名].spec.ts, src/**/*.test.ts

## 作業ディレクトリ
../oshicall-feat-new-function

## 依頼内容

### Step 1: 実装方針（まず報告）

【実装方針】
■ 修正ファイル:
  - [ファイル]: [変更内容]

■ リスク・影響範囲:
  - [既存機能への影響]

### Step 2: 実装（承認後）

1. 1ファイルずつ修正
2. 各修正後にテストを実行して報告
3. 全テスト通過を確認

### 完了条件
npm run ci  # 全てパス

### 重要ルール
- テストファイルは変更しない
- テストが通らない場合は実装を修正
- 業務仕様と矛盾する場合は Phase 0 に戻る
- 作業は指定されたWorktreeディレクトリで行う
```

---

## Phase 3: レビューとマージ

### プロセス

1. AIの作業が完了したら、メイン環境（またはGitHub）でDiffを確認
2. 問題なければマージ
3. Worktreeの削除

```bash
git worktree remove ../oshicall-feat-new-function
git branch -d feat/new-function
```

### GitHubへのPush（Routine化）

実装完了後は、必ずGitHubにPushします。

#### 手順

1. **変更ファイルの確認**
   ```bash
   git status
   ```

2. **関連ファイルのみをステージング**
   ```bash
   # 主要な変更ファイルのみを追加（一時ファイルや自動生成ファイルは除外）
   git add [変更したファイル]
   ```

3. **コミット**
   ```bash
   git commit -m "feat: [機能名] の実装

   - 変更内容1
   - 変更内容2
   - ドキュメント更新"
   ```

4. **Push**
   ```bash
   git push origin main
   ```

#### コミットメッセージのフォーマット
- `feat`: 新機能追加
- `fix`: バグ修正
- `docs`: ドキュメント更新
- `refactor`: リファクタリング
- `test`: テスト追加・修正
- `chore`: その他の変更

#### 除外すべきファイル
以下のファイルは通常コミットに含めません：
- `supabase/.temp/*` - 一時ファイル
- `node_modules/` - 依存パッケージ
- `.env*` - 環境変数ファイル（`.example` は含める）
- 自動生成ファイル

詳細は [/docs/ai_workflow/CODE_CHANGE_WORKFLOW.md](./CODE_CHANGE_WORKFLOW.md) の「フェーズ5: GitHubへのPush」を参照してください。

---

## Phase 4 & 5: PR・CI・デプロイ

（前回と同様のため省略）

---

## 🛡️ 安全なDB変更フロー

DB変更（マイグレーション）は最も慎重に行う必要があります。**AIに直接本番DBを操作させてはいけません。**

### ルール
1. **直接実行禁止**: AIに `supabase db push` を本番環境に対して実行させない
2. **マイグレーションファイル**: 必ずSQLファイルを作成させる
3. **人間によるレビュー**: 生成されたSQLを目視確認する

### フロー
1. **AI**: 「ユーザーテーブルにカラムを追加したいです」
2. **AI**: `supabase/migrations/2025xxxx_add_column.sql` を作成
3. **User**: ファイルの中身を確認
4. **User**: ローカル/Stagingで `supabase db push` を実行して確認
5. **User**: 問題なければCommit & Push

---

## 🤖 ブラウザテスト自動化 (Best Practice)

個人開発では手動テストの工数がボトルネックになります。

### 推奨構成
- **フレームワーク**: Playwright (高速、高機能)
- **ディレクトリ**: `e2e/`

### AI活用法
「この機能のテストコードを書いて」と頼むだけでなく、**「このテストコードを実行して、失敗したら修正して」** というループをAIに回させることが重要です。

1. AIに実装させる
2. AIにテストを書かせる
3. AIにテストを実行させる (`npm run test:e2e`)
4. エラーが出たらAIが自己修正する

このサイクルをWorktree内で行うことで、メイン環境を汚さずに品質を担保できます。

---

## 📊 仕様変更時のフロー判定

```
問題/要望を受け取る
       ↓
┌─────────────────────────────────────────┐
│ Q: 業務仕様（ビジネスルール）の変更が必要？ │
└─────────────────────────────────────────┘
       ↓
   ┌───┴───┐
   ↓       ↓
  YES      NO
   ↓       ↓
Phase 0    │
業務仕様   │
を更新     │
   ↓       ↓
   └───┬───┘
       ↓
┌─────────────────────────────────────────┐
│ Phase 1: テスト設計                      │
│ （業務仕様の BR-xxx に対応するテスト）    │
└─────────────────────────────────────────┘
       ↓
┌─────────────────────────────────────────┐
│ Phase 2: 機能設計・実装                  │
│ （テストが通るように実装）               │
└─────────────────────────────────────────┘
```

### 判定例

| ケース | 業務仕様変更 | 例 |
|--------|--------------|-----|
| バグ修正 | 不要 | 通話終了時にステータスが更新されない |
| UI改善 | 不要 | ボタンの配置変更、デザイン調整 |
| 仕様変更 | **必要** | オークション終了時間のルール変更 |
| 新機能 | **必要** | 新しい決済方法の追加 |

---

## 🛠️ コマンド一覧

```bash
# 開発
npm run dev              # フロントエンド開発サーバー
npm run dev:server       # バックエンド開発サーバー

# テスト
npm run test             # ユニットテスト
npm run test:e2e         # E2Eテスト

# 品質チェック
npm run typecheck        # 型チェック
npm run lint             # Lint

# CI相当
npm run ci               # 全チェック
```

---

## 📝 開発チェックリスト

```markdown
## [機能名] 開発チェックリスト

### Phase 0: 業務仕様
- [ ] 関連する業務仕様を確認: /docs/business/___
- [ ] 業務仕様の更新要否を判定
- [ ] （必要な場合）業務仕様を更新・承認

### Phase 1: テスト設計
- [ ] 対象BR: BR-___, BR-___
- [ ] テスト計画書作成
- [ ] テストコード作成
- [ ] レビュー & 承認

### Phase 2: 機能設計・実装
- [ ] Git Worktreeの作成
- [ ] 機能仕様作成/更新
- [ ] 実装完了
- [ ] npm run ci 全パス

### Phase 3: レビューとマージ
- [ ] Diff確認
- [ ] Worktreeの削除
- [ ] GitHubへのPush

### Phase 4: PR & CI
- [ ] PR 作成
- [ ] CI 通過
- [ ] マージ

### Phase 5: デプロイ
- [ ] Staging 確認
- [ ] Production デプロイ
```

---

## 変更履歴

| 日付 | 変更内容 |
|------|----------|
| 2026-01-02 | AI_TDD_PROCESS_v3.md と AI_DEVELOPMENT_GUIDE.md を統合して新規作成 |
| 2025-01-01 | v2: 業務仕様と機能仕様を分離、原本管理の考え方を追加 |

---

## 関連ドキュメント

- [コード変更ワークフロー](./CODE_CHANGE_WORKFLOW.md) - コード変更の詳細なワークフロー
- [業務仕様](../business/) - 業務仕様ドキュメント
- [機能仕様](../functional/) - 機能仕様ドキュメント
- [テスト計画](../test/plans/) - テスト計画書

